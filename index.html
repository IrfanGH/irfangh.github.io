<!DOCTYPE html>
<html lang="en">

<head>
	<title>XR Concrete Corbel</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<meta name="author" content="ETH Zurich - kfm Research">
	<link type="text/css" rel="stylesheet" href="https://irfangh.github.io/style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.js" crossorigin="anonymous"></script>
  <!-- <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script> -->
	<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/OBJLoader.js"></script>
</head>

<body>
	<div style="z-index: 99999;position: absolute;margin-left: 50%; background: #fff; color: #000" id="hideShow">Hide / Show!</div>
	<script type="module">
    import { ARButton } from 'https://unpkg.com/three@0.126.0/examples/jsm/webxr/ARButton.js';

		let container;
		let camera, scene, renderer;
		let reticle;
		let controller;
		let loader; // we need to create a variable for a gltf model loader

		let locationSet = false; // Check wether the user has defined the inital position of the model
		let objHidden = true;

		var concreteMaterial = new THREE.MeshBasicMaterial( { color: "rgb(195,195,195)" } );
		var elastomerMaterial = new THREE.MeshBasicMaterial( { color: "rgb(0,0,0)" } );
		var dimensioningMaterial = new THREE.MeshBasicMaterial( { color: "rgb(255,0,0)" } );

		init();
		animate();

		function init() {
			const container = document.createElement('div');
			document.body.appendChild(container);

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.xr.enabled = true; // we have to enable the renderer for webxr
			container.appendChild(renderer.domElement);

			var light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
			light.position.set(0.5, 1, 0.25);
			scene.add(light);

			controller = renderer.xr.getController(0);
			controller.addEventListener('select', onSelect);
			scene.add(controller);

			addReticleToScene();

			const button = ARButton.createButton(renderer, {
				requiredFeatures: ["hit-test"]
			});
			document.body.appendChild(button);
			renderer.domElement.style.display = "none";

			window.addEventListener('resize', onWindowResize, false);
		}

		function loadModel(url) {
			return new Promise(resolve => {
				// new THREE.GLTFLoader().load(url, resolve);
				new THREE.OBJLoader().load(url, resolve);
			});
		}

    function placeModel(reticleFixed) {

			let model1, model2, model3;

			let p1 = loadModel('https://irfangh.github.io/Models/Konsole_01_1_Beton.obj').then(result => {  model1 = result; });
			let p2 = loadModel('https://irfangh.github.io/Models/Konsole_01_2_Elastomer.obj').then(result => {  model2 = result; });
			let p3 = loadModel('https://irfangh.github.io/Models/Konsole_01_3_Bemessung.obj').then(result => {  model3 = result; });

			//if all Promises resolved 
			Promise.all([p1,p2,p3]).then(() => {
				// //do something to the model
				// model1.position.set(0,0,0);
				// model2.position.set(0,20,0);
				// model3.position.set(0,50,0);
				const sf = 1/100;
				model1.scale.set(sf, sf, sf);
				model2.scale.set(sf, sf, sf);
				model3.scale.set(sf, sf, sf);
				//add model to the scene
				scene.add(model1);
				scene.add(model2);
				scene.add(model3);

				model1.position.setFromMatrixPosition(reticleFixed.matrix);
				model1.quaternion.setFromRotationMatrix(reticleFixed.matrix);
				model2.position.setFromMatrixPosition(reticleFixed.matrix);
				model2.quaternion.setFromRotationMatrix(reticleFixed.matrix);
				model3.position.setFromMatrixPosition(reticleFixed.matrix);
				model3.quaternion.setFromRotationMatrix(reticleFixed.matrix);

				model1.rotation.y = THREE.Math.degToRad(225);
				model2.rotation.y = THREE.Math.degToRad(225);
				model3.rotation.y = THREE.Math.degToRad(225);

				

				model1.traverse( function( child ) {
		      if ( child instanceof THREE.Mesh ) {
		          child.material = concreteMaterial;
						}
				} );

				model2.traverse( function( child ) {
		      if ( child instanceof THREE.Mesh ) {
		          child.material = elastomerMaterial;
						}
				} );

				model3.traverse( function( child ) {
		      if ( child instanceof THREE.Mesh ) {
		          child.material = dimensioningMaterial;
						}
				} );

				document.getElementById("hideShow").addEventListener("click", function(){
					if(objHidden) {
						objHidden = false;
						// code to show object

						model1.visible = true;
						model2.visible = true;
						model3.visible = true;
					} else {
						objHidden = true;
						// code to hide object
						
						model1.visible = false;
						model2.visible = false;
						model3.visible = false;
					}
				});

			});

    }

		function addReticleToScene() {
        const geometry = new THREE.RingBufferGeometry(0.15, 0.2, 32).rotateX(
          -Math.PI / 2
        );
        const material = new THREE.MeshBasicMaterial();

        reticle = new THREE.Mesh(geometry, material);

        // we will calculate the position and rotation of this reticle every frame manually
        // in the render() function so matrixAutoUpdate is set to false
        reticle.matrixAutoUpdate = false;
        reticle.visible = false; // we start with the reticle not visible
        scene.add(reticle);

        // optional axis helper you can add to an object
        // reticle.add(new THREE.AxesHelper(1));
      }

      function onSelect() {        
        if (reticle.visible) {
					if (!locationSet){

						placeModel(reticle);
						locationSet = true;
						
					}
        }
      }

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			renderer.setAnimationLoop(render);
		}


		let hitTestSource = null;
		let localSpace = null;
		let hitTestSourceInitialized = false;

		// This function gets called just once to initialize a hitTestSource
		// The purpose of this function is to get a) a hit test source and b) a reference space
		async function initializeHitTestSource() {
			const session = renderer.xr.getSession(); // XRSession
			
			// Reference spaces express relationships between an origin and the world.

			// For hit testing, we use the "viewer" reference space,
			// which is based on the device's pose at the time of the hit test.
			const viewerSpace = await session.requestReferenceSpace("viewer");
			hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

			// We're going to use the reference space of "local" for drawing things.
			// which gives us stability in terms of the environment.
			// read more here: https://developer.mozilla.org/en-US/docs/Web/API/XRReferenceSpace
			localSpace = await session.requestReferenceSpace("local");

			// set this to true so we don't request another hit source for the rest of the session
			hitTestSourceInitialized = true;
			
			// In case we close the AR session by hitting the button "End AR"
			session.addEventListener("end", () => {
				hitTestSourceInitialized = false;
				hitTestSource = null;
			});
		}

		// the callback from 'setAnimationLoop' can also return a timestamp
		// and an XRFrame, which provides access to the information needed in
		// order to render a single frame of animation for an XRSession describing
		// a VR or AR sccene.
		function render(timestamp, frame) {
			if (frame) {
				if (!locationSet){
					// 1. create a hit test source once and keep it for all the frames
					// this gets called only once
					if (!hitTestSourceInitialized) {
						initializeHitTestSource();
					}

					// 2. get hit test results
					if (hitTestSourceInitialized) {
						// we get the hit test results for a particular frame
						const hitTestResults = frame.getHitTestResults(hitTestSource);

						// XRHitTestResults The hit test may find multiple surfaces. The first one in the array is the one closest to the camera.
						if (hitTestResults.length > 0) {
							const hit = hitTestResults[0];
							// Get a pose from the hit test result. The pose represents the pose of a point on a surface.
							const pose = hit.getPose(localSpace);

							reticle.visible = true;
							// Transform/move the reticle image to the hit test position
							reticle.matrix.fromArray(pose.transform.matrix);
						} else {
							reticle.visible = false;
						}
					}
				}
				renderer.render(scene, camera);
			}
		}

	</script>
</body>

</html>